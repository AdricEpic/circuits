diff --git a/circuits/core/manager.py b/circuits/core/manager.py
--- a/circuits/core/manager.py
+++ b/circuits/core/manager.py
@@ -43,7 +43,7 @@
     except:
         HAS_MULTIPROCESSING = 0
 
-from .values import Value
+from .values import Result
 from .events import Started, Stopped, Signal
 from .events import Error, Success, Failure, Filter, Start, End
 
@@ -404,14 +404,14 @@
 
         event.channel = (target, channel)
 
-        event.value = Value(event, self)
+        event.result = Result(event, self)
 
         if event.start is not None:
             self.fire(Start(event), *event.start)
 
         self.root._fire(event, (target, channel))
 
-        return event.value
+        return event.result
 
     fire = push = fireEvent
 
@@ -448,14 +448,14 @@
                     retval = handler(event, *eargs, **ekwargs)
                 else:
                     retval = handler(*eargs, **ekwargs)
-                event.value.value = retval
+                event.result.value = retval
             except (KeyboardInterrupt, SystemExit):
                 raise
             except:
                 etype, evalue, etraceback = _exc_info()
-                event.value.errors = True
+                event.result.errors = True
                 traceback = format_tb(etraceback)
-                event.value.value = (etype, evalue, traceback)
+                event.result.value = (etype, evalue, traceback)
                 if event.failure is not None:
                     error = (etype, evalue, traceback)
                     self.fire(Failure(event, handler, error), *event.failure)
diff --git a/circuits/core/values.py b/circuits/core/values.py
--- a/circuits/core/values.py
+++ b/circuits/core/values.py
@@ -22,11 +22,138 @@
 
         super(ValueChanged, self).__init__(value)
 
+class Proxy(object):
+
+    __slots__ = ["_obj", "__weakref__"]
+
+    def __init__(self, obj):
+        object.__setattr__(self, "_obj", obj)
+
+    # proxying (special cases)
+    #
+    def __getattribute__(self, name):
+        print("__getattribute__")
+        print(name)
+        return getattr(object.__getattribute__(self, "_obj"), name)
+    def __delattr__(self, name):
+        print("__delattr__")
+        print(name)
+        delattr(object.__getattribute__(self, "_obj"), name)
+    def __setattr__(self, name, value):
+        print("__setattr__")
+        print(name)
+        print(value)
+        setattr(object.__getattribute__(self, "_obj"), name, value)
+
+    def __nonzero__(self):
+        print("__nonzero__")
+        return bool(object.__getattribute__(self, "_obj"))
+    def __str__(self):
+        print("__str__")
+        return str(object.__getattribute__(self, "_obj"))
+    def __repr__(self):
+        print("__repr__")
+        return repr(object.__getattribute__(self, "_obj"))
+
+    #
+    # factories
+    #
+    _special_names = [
+        "__abs__", "__add__", "__and__", "__call__", "__cmp__", "__coerce__", 
+        "__contains__", "__delitem__", "__delslice__", "__div__", "__divmod__", 
+        "__eq__", "__float__", "__floordiv__", "__ge__", "__getitem__", 
+        "__getslice__", "__gt__", "__hash__", "__hex__", "__iadd__", "__iand__",
+        "__idiv__", "__idivmod__", "__ifloordiv__", "__ilshift__", "__imod__", 
+        "__imul__", "__int__", "__invert__", "__ior__", "__ipow__", "__irshift__", 
+        "__isub__", "__iter__", "__itruediv__", "__ixor__", "__le__", "__len__", 
+        "__long__", "__lshift__", "__lt__", "__mod__", "__mul__", "__ne__", 
+        "__neg__", "__oct__", "__or__", "__pos__", "__pow__", "__radd__", 
+        "__rand__", "__rdiv__", "__rdivmod__", "__reduce__", "__reduce_ex__", 
+        "__repr__", "__reversed__", "__rfloorfiv__", "__rlshift__", "__rmod__", 
+        "__rmul__", "__ror__", "__rpow__", "__rrshift__", "__rshift__", "__rsub__", 
+        "__rtruediv__", "__rxor__", "__setitem__", "__setslice__", "__sub__", 
+        "__truediv__", "__xor__", "next",
+    ]
+    
+    @classmethod
+    def _create_class_proxy(cls, theclass):
+        """creates a proxy for the given class"""
+        
+        def make_method(name):
+            def method(self, *fargs, **fkwargs):
+                args, kwargs = [], {}
+                for i, farg in enumerate(fargs):
+                    if isinstance(farg, self.__class__):
+                        args.append(object.__getattribute__(farg, "_obj"))
+                    else:
+                        args.append(farg)
+
+                for k, v in fkwargs.items():
+                    if isinstance(v, self.__class__):
+                        kwargs[k] = object.__getattribute__(v, "_obj")
+                    else:
+                        kwargs[k] = v
+
+                print(self, name, args, kwargs)
+
+                return getattr(object.__getattribute__(self, "_obj"),
+                        name)(*args, **kwargs)
+            return method
+        
+        namespace = {}
+        for name in cls._special_names:
+            if hasattr(theclass, name):
+                namespace[name] = make_method(name)
+        return type("%s(%s)" % (cls.__name__, theclass.__name__), (cls,),
+                namespace)
+    
+    def __new__(cls, obj, *args, **kwargs):
+        """
+        creates an proxy instance referencing `obj`. (obj, *args, **kwargs) are
+        passed to this class" __init__, so deriving classes can define an 
+        __init__ method of their own.
+        note: _class_proxy_cache is unique per deriving class (each deriving
+        class must hold its own cache)
+        """
+        try:
+            cache = cls.__dict__["_class_proxy_cache"]
+        except KeyError:
+            cls._class_proxy_cache = cache = {}
+        try:
+            theclass = cache[obj.__class__]
+        except KeyError:
+            cache[obj.__class__] = theclass = cls._create_class_proxy(
+                    obj.__class__)
+        ins = object.__new__(theclass)
+        theclass.__init__(ins, obj, *args, **kwargs)
+        return ins
 
 class Value(object):
-    """Create a new future Value Object
 
-    Creates a new future Value Object which is used by Event Objects and the
+    def __init__(self, value=None):
+        super(Value, self).__init__()
+
+        self._value = Proxy(value)
+
+    def __get__(self, instance, owner):
+        print("Retriving value...")
+        print(instance)
+        print(owner)
+
+        return self._value
+
+    def __set__(self, instance, value):
+        print("Setting value...")
+        print(instance)
+        print(value)
+
+        instance.done = True
+        self._value = Proxy(value)
+
+class Result(object):
+    """Create a new Result Object
+
+    Creates a new Result Object which is used by Event Objects and the
     Manager to store the result(s) of an Event Handler's exeuction of some
     Event in the system.
 
@@ -39,90 +166,31 @@
     :param onSet: The channel used when triggering ValueChagned events.
     :type  onSet: A (channel, target) tuple.
 
-    :ivar result: True if this value has been changed.
-    :ivar errors: True if while setting this value an exception occured.
+    :ivar done:   True if this result has been set.
+    :ivar errors: True if while setting this result an exception occured.
+    """
 
-    This is a Future/Promise implementation.
-    """
+    value = Value()
 
     def __init__(self, event=None, manager=None, onSet=None):
         "x.__init__(...) initializes x; see x.__class__.__doc__ for signature"
 
+        super(Result, self).__init__()
+
         self.event = event
         self.manager = manager
 
         self.onSet = onSet
 
-        self.result = False
+        self.done = False
         self.errors = False
-        self._parent = self
-        self._value = None
 
     def __getstate__(self):
-        keys = ("event", "onSet", "result", "errors", "_value")
+        keys = ("event", "onSet", "done", "errors", "value")
         return dict([(k, getattr(self, k, None)) for k in keys])
 
-    def __contains__(self, y):
-        value = self.value
-        return y in value if isinstance(value, list) else y == value
-
-    def __getitem__(self, y):
-        v = self.value[y]
-        if isinstance(v, Value):
-            return v.value
-        else:
-            return v
-
-    def __iter__(self):
-        return map(lambda v: v.value if isinstance(v, Value) else v,
-                self.value)
-
     def __repr__(self):
         "x.__repr__() <==> repr(x)"
 
-        value = ""
-        if self.result:
-            value = repr(self.value)
-
-        format = "<Value (%s) result: %r errors: %r for %r"
-        return format % (value, self.result, self.errors, self.event)
-
-    def __str__(self):
-        "x.__str__() <==> str(x)"
-
-        return str(self.value)
-
-    def getValue(self):
-        value = self._value
-        while isinstance(value, Value):
-            value = value._value
-        return value
-
-    def setValue(self, value):
-        if isinstance(value, Value):
-            value._parent = self
-
-        if self.result and isinstance(self._value, list):
-            self._value.append(value)
-        elif self.result:
-            self._value = [self._value]
-            self._value.append(value)
-        else:
-            self._value = value
-
-        def notify(o, v):
-            if not isinstance(v, Value) and v is not None:
-                o.result = True
-                if o.manager is not None and o.onSet is not None:
-                    o.manager.fireEvent(ValueChanged(o), *o.onSet)
-            elif isinstance(v, Value):
-                o.errors = v.errors
-                o.result = v.result
-            if not o._parent == o:
-                o._parent.errors = o.errors
-                o._parent.result = o.result
-                notify(o._parent, v)
-        
-        notify(self, value)
-
-    value = property(getValue, setValue, None, "Value of this Value")
+        format = "<Result (done: %r errors: %r) for %r>"
+        return format % (self.done, self.errors, self.event)
diff --git a/tmp/lazy_evaluation.diff b/tmp/lazy_evaluation.diff
--- a/tmp/lazy_evaluation.diff
+++ b/tmp/lazy_evaluation.diff
@@ -48,7 +48,7 @@
 diff --git a/circuits/core/values.py b/circuits/core/values.py
 --- a/circuits/core/values.py
 +++ b/circuits/core/values.py
-@@ -22,11 +22,124 @@
+@@ -22,11 +22,138 @@
  
          super(ValueChanged, self).__init__(value)
  
@@ -58,7 +58,6 @@
 +
 +    def __init__(self, obj):
 +        object.__setattr__(self, "_obj", obj)
-+    
 +
 +    # proxying (special cases)
 +    #
@@ -111,19 +110,32 @@
 +        """creates a proxy for the given class"""
 +        
 +        def make_method(name):
-+            def method(self, *args, **kw):
-+                print(name)
-+                print(args)
-+                print(kw)
++            def method(self, *fargs, **fkwargs):
++                args, kwargs = [], {}
++                for i, farg in enumerate(fargs):
++                    if isinstance(farg, self.__class__):
++                        args.append(object.__getattribute__(farg, "_obj"))
++                    else:
++                        args.append(farg)
++
++                for k, v in fkwargs.items():
++                    if isinstance(v, self.__class__):
++                        kwargs[k] = object.__getattribute__(v, "_obj")
++                    else:
++                        kwargs[k] = v
++
++                print(self, name, args, kwargs)
++
 +                return getattr(object.__getattribute__(self, "_obj"),
-+                        name)(*args, **kw)
++                        name)(*args, **kwargs)
 +            return method
 +        
 +        namespace = {}
 +        for name in cls._special_names:
 +            if hasattr(theclass, name):
 +                namespace[name] = make_method(name)
-+        return type("%s(%s)" % (cls.__name__, theclass.__name__), (cls,), namespace)
++        return type("%s(%s)" % (cls.__name__, theclass.__name__), (cls,),
++                namespace)
 +    
 +    def __new__(cls, obj, *args, **kwargs):
 +        """
@@ -140,7 +152,8 @@
 +        try:
 +            theclass = cache[obj.__class__]
 +        except KeyError:
-+            cache[obj.__class__] = theclass = cls._create_class_proxy(obj.__class__)
++            cache[obj.__class__] = theclass = cls._create_class_proxy(
++                    obj.__class__)
 +        ins = object.__new__(theclass)
 +        theclass.__init__(ins, obj, *args, **kwargs)
 +        return ins
@@ -166,6 +179,7 @@
 +        print(instance)
 +        print(value)
 +
++        instance.done = True
 +        self._value = Proxy(value)
 +
 +class Result(object):
@@ -175,7 +189,7 @@
      Manager to store the result(s) of an Event Handler's exeuction of some
      Event in the system.
  
-@@ -39,90 +152,31 @@
+@@ -39,90 +166,31 @@
      :param onSet: The channel used when triggering ValueChagned events.
      :type  onSet: A (channel, target) tuple.
  
@@ -215,317 +229,4 @@
 -        return y in value if isinstance(value, list) else y == value
 -
 -    def __getitem__(self, y):
--        v = self.value[y]
--        if isinstance(v, Value):
--            return v.value
--        else:
--            return v
--
--    def __iter__(self):
--        return map(lambda v: v.value if isinstance(v, Value) else v,
--                self.value)
--
-     def __repr__(self):
-         "x.__repr__() <==> repr(x)"
- 
--        value = ""
--        if self.result:
--            value = repr(self.value)
--
--        format = "<Value (%s) result: %r errors: %r for %r"
--        return format % (value, self.result, self.errors, self.event)
--
--    def __str__(self):
--        "x.__str__() <==> str(x)"
--
--        return str(self.value)
--
--    def getValue(self):
--        value = self._value
--        while isinstance(value, Value):
--            value = value._value
--        return value
--
--    def setValue(self, value):
--        if isinstance(value, Value):
--            value._parent = self
--
--        if self.result and isinstance(self._value, list):
--            self._value.append(value)
--        elif self.result:
--            self._value = [self._value]
--            self._value.append(value)
--        else:
--            self._value = value
--
--        def notify(o, v):
--            if not isinstance(v, Value) and v is not None:
--                o.result = True
--                if o.manager is not None and o.onSet is not None:
--                    o.manager.fireEvent(ValueChanged(o), *o.onSet)
--            elif isinstance(v, Value):
--                o.errors = v.errors
--                o.result = v.result
--            if not o._parent == o:
--                o._parent.errors = o.errors
--                o._parent.result = o.result
--                notify(o._parent, v)
--        
--        notify(self, value)
--
--    value = property(getValue, setValue, None, "Value of this Value")
-+        format = "<Result (done: %r errors: %r) for %r>"
-+        return format % (self.done, self.errors, self.event)
-diff --git a/tmp/lazy_evaluation.diff b/tmp/lazy_evaluation.diff
---- a/tmp/lazy_evaluation.diff
-+++ b/tmp/lazy_evaluation.diff
-@@ -48,19 +48,111 @@
- diff --git a/circuits/core/values.py b/circuits/core/values.py
- --- a/circuits/core/values.py
- +++ b/circuits/core/values.py
--@@ -22,11 +22,31 @@
-+@@ -22,11 +22,124 @@
-  
-          super(ValueChanged, self).__init__(value)
-  
--+class Value(object):
-++class Proxy(object):
-++
-++    __slots__ = ["_obj", "__weakref__"]
-++
-++    def __init__(self, obj):
-++        object.__setattr__(self, "_obj", obj)
-++    
-++
-++    # proxying (special cases)
-++    #
-++    def __getattribute__(self, name):
-++        print("__getattribute__")
-++        print(name)
-++        return getattr(object.__getattribute__(self, "_obj"), name)
-++    def __delattr__(self, name):
-++        print("__delattr__")
-++        print(name)
-++        delattr(object.__getattribute__(self, "_obj"), name)
-++    def __setattr__(self, name, value):
-++        print("__setattr__")
-++        print(name)
-++        print(value)
-++        setattr(object.__getattribute__(self, "_obj"), name, value)
-++
-++    def __nonzero__(self):
-++        print("__nonzero__")
-++        return bool(object.__getattribute__(self, "_obj"))
-++    def __str__(self):
-++        print("__str__")
-++        return str(object.__getattribute__(self, "_obj"))
-++    def __repr__(self):
-++        print("__repr__")
-++        return repr(object.__getattribute__(self, "_obj"))
-++
-++    #
-++    # factories
-++    #
-++    _special_names = [
-++        "__abs__", "__add__", "__and__", "__call__", "__cmp__", "__coerce__", 
-++        "__contains__", "__delitem__", "__delslice__", "__div__", "__divmod__", 
-++        "__eq__", "__float__", "__floordiv__", "__ge__", "__getitem__", 
-++        "__getslice__", "__gt__", "__hash__", "__hex__", "__iadd__", "__iand__",
-++        "__idiv__", "__idivmod__", "__ifloordiv__", "__ilshift__", "__imod__", 
-++        "__imul__", "__int__", "__invert__", "__ior__", "__ipow__", "__irshift__", 
-++        "__isub__", "__iter__", "__itruediv__", "__ixor__", "__le__", "__len__", 
-++        "__long__", "__lshift__", "__lt__", "__mod__", "__mul__", "__ne__", 
-++        "__neg__", "__oct__", "__or__", "__pos__", "__pow__", "__radd__", 
-++        "__rand__", "__rdiv__", "__rdivmod__", "__reduce__", "__reduce_ex__", 
-++        "__repr__", "__reversed__", "__rfloorfiv__", "__rlshift__", "__rmod__", 
-++        "__rmul__", "__ror__", "__rpow__", "__rrshift__", "__rshift__", "__rsub__", 
-++        "__rtruediv__", "__rxor__", "__setitem__", "__setslice__", "__sub__", 
-++        "__truediv__", "__xor__", "next",
-++    ]
-++    
-++    @classmethod
-++    def _create_class_proxy(cls, theclass):
-++        """creates a proxy for the given class"""
-++        
-++        def make_method(name):
-++            def method(self, *args, **kw):
-++                print(name)
-++                print(args)
-++                print(kw)
-++                return getattr(object.__getattribute__(self, "_obj"),
-++                        name)(*args, **kw)
-++            return method
-++        
-++        namespace = {}
-++        for name in cls._special_names:
-++            if hasattr(theclass, name):
-++                namespace[name] = make_method(name)
-++        return type("%s(%s)" % (cls.__name__, theclass.__name__), (cls,), namespace)
-++    
-++    def __new__(cls, obj, *args, **kwargs):
-++        """
-++        creates an proxy instance referencing `obj`. (obj, *args, **kwargs) are
-++        passed to this class" __init__, so deriving classes can define an 
-++        __init__ method of their own.
-++        note: _class_proxy_cache is unique per deriving class (each deriving
-++        class must hold its own cache)
-++        """
-++        try:
-++            cache = cls.__dict__["_class_proxy_cache"]
-++        except KeyError:
-++            cls._class_proxy_cache = cache = {}
-++        try:
-++            theclass = cache[obj.__class__]
-++        except KeyError:
-++            cache[obj.__class__] = theclass = cls._create_class_proxy(obj.__class__)
-++        ins = object.__new__(theclass)
-++        theclass.__init__(ins, obj, *args, **kwargs)
-++        return ins
-  
---class Value(object):
-+ class Value(object):
- -    """Create a new future Value Object
-+ 
-+-    Creates a new future Value Object which is used by Event Objects and the
- +    def __init__(self, value=None):
- +        super(Value, self).__init__()
-- 
---    Creates a new future Value Object which is used by Event Objects and the
--+        self._value = value
-++
-++        self._value = Proxy(value)
- +
- +    def __get__(self, instance, owner):
- +        print("Retriving value...")
-@@ -74,7 +166,7 @@
- +        print(instance)
- +        print(value)
- +
--+        self._value = value
-++        self._value = Proxy(value)
- +
- +class Result(object):
- +    """Create a new Result Object
-@@ -83,7 +175,7 @@
-      Manager to store the result(s) of an Event Handler's exeuction of some
-      Event in the system.
-  
--@@ -39,90 +59,31 @@
-+@@ -39,90 +152,31 @@
-      :param onSet: The channel used when triggering ValueChagned events.
-      :type  onSet: A (channel, target) tuple.
-  
-@@ -144,77 +236,4 @@
- -        return format % (value, self.result, self.errors, self.event)
- -
- -    def __str__(self):
---        "x.__str__() <==> str(x)"
---
---        return str(self.value)
---
---    def getValue(self):
---        value = self._value
---        while isinstance(value, Value):
---            value = value._value
---        return value
---
---    def setValue(self, value):
---        if isinstance(value, Value):
---            value._parent = self
---
---        if self.result and isinstance(self._value, list):
---            self._value.append(value)
---        elif self.result:
---            self._value = [self._value]
---            self._value.append(value)
---        else:
---            self._value = value
---
---        def notify(o, v):
---            if not isinstance(v, Value) and v is not None:
---                o.result = True
---                if o.manager is not None and o.onSet is not None:
---                    o.manager.fireEvent(ValueChanged(o), *o.onSet)
---            elif isinstance(v, Value):
---                o.errors = v.errors
---                o.result = v.result
---            if not o._parent == o:
---                o._parent.errors = o.errors
---                o._parent.result = o.result
---                notify(o._parent, v)
---        
---        notify(self, value)
---
---    value = property(getValue, setValue, None, "Value of this Value")
--+        format = "<Result (done: %r errors: %r) for %r>"
--+        return format % (self.done, self.errors, self.event)
--diff --git a/tmp/test_lazy_evaluation.py b/tmp/test_lazy_evaluation.py
--new file mode 100755
----- /dev/null
--+++ b/tmp/test_lazy_evaluation.py
--@@ -0,0 +1,29 @@
--+#!/usr/bin/env python
--+
--+from circuits import Component, Event
--+
--+class Test(Event):
--+    """Test Event"""
--+
--+class Foo(Event):
--+    """Foo Event"""
--+
--+class Bar(Event):
--+    """Bar Event"""
--+
--+class App(Component):
--+
--+    def foo(self):
--+        return 1
--+
--+    def bar(self):
--+        return 2
--+
--+    def test(self):
--+        a = self.fire(Foo())
--+        b = self.fire(Bar())
--+        return a.value + b.value
--+
--+from circuits import Debugger
--+app = App() + Debugger()
--+app.start()
-+-        "x.__st
-\ No newline at end of file
-diff --git a/tmp/test_lazy_evaluation.py b/tmp/test_lazy_evaluation.py
-new file mode 100755
---- /dev/null
-+++ b/tmp/test_lazy_evaluation.py
-@@ -0,0 +1,29 @@
-+#!/usr/bin/env python
-+
-+from circuits import Component, Event
-+
-+class Test(Event):
-+    """Test Event"""
-+
-+class Foo(Event):
-+    """Foo Event"""
-+
-+class Bar(Event):
-+    """Bar Event"""
-+
-+class App(Component):
-+
-+    def foo(self):
-+        return 1
-+
-+    def bar(self):
-+        return 2
-+
-+    def test(self):
-+        a = self.fire(Foo())
-+        b = self.fire(Bar())
-+        return a.value + b.value
-+
-+from circuits import Debugger
-+app = App() + Debugger()
-+app.start()
+- 
\ No newline at end of file
