diff --git a/circuits/core/manager.py b/circuits/core/manager.py
--- a/circuits/core/manager.py
+++ b/circuits/core/manager.py
@@ -43,7 +43,7 @@
     except:
         HAS_MULTIPROCESSING = 0
 
-from .values import Value
+from .values import Result
 from .events import Started, Stopped, Signal
 from .events import Error, Success, Failure, Filter, Start, End
 
@@ -404,14 +404,14 @@
 
         event.channel = (target, channel)
 
-        event.value = Value(event, self)
+        event.result = Result(event, self)
 
         if event.start is not None:
             self.fire(Start(event), *event.start)
 
         self.root._fire(event, (target, channel))
 
-        return event.value
+        return event.result
 
     fire = push = fireEvent
 
@@ -448,14 +448,14 @@
                     retval = handler(event, *eargs, **ekwargs)
                 else:
                     retval = handler(*eargs, **ekwargs)
-                event.value.value = retval
+                event.result.value = retval
             except (KeyboardInterrupt, SystemExit):
                 raise
             except:
                 etype, evalue, etraceback = _exc_info()
-                event.value.errors = True
+                event.result.errors = True
                 traceback = format_tb(etraceback)
-                event.value.value = (etype, evalue, traceback)
+                event.result.value = (etype, evalue, traceback)
                 if event.failure is not None:
                     error = (etype, evalue, traceback)
                     self.fire(Failure(event, handler, error), *event.failure)
diff --git a/circuits/core/values.py b/circuits/core/values.py
--- a/circuits/core/values.py
+++ b/circuits/core/values.py
@@ -22,11 +22,31 @@
 
         super(ValueChanged, self).__init__(value)
 
+class Value(object):
 
-class Value(object):
-    """Create a new future Value Object
+    def __init__(self, value=None):
+        super(Value, self).__init__()
 
-    Creates a new future Value Object which is used by Event Objects and the
+        self._value = value
+
+    def __get__(self, instance, owner):
+        print("Retriving value...")
+        print(instance)
+        print(owner)
+
+        return self._value
+
+    def __set__(self, instance, value):
+        print("Setting value...")
+        print(instance)
+        print(value)
+
+        self._value = value
+
+class Result(object):
+    """Create a new Result Object
+
+    Creates a new Result Object which is used by Event Objects and the
     Manager to store the result(s) of an Event Handler's exeuction of some
     Event in the system.
 
@@ -39,90 +59,31 @@
     :param onSet: The channel used when triggering ValueChagned events.
     :type  onSet: A (channel, target) tuple.
 
-    :ivar result: True if this value has been changed.
-    :ivar errors: True if while setting this value an exception occured.
+    :ivar done:   True if this result has been set.
+    :ivar errors: True if while setting this result an exception occured.
+    """
 
-    This is a Future/Promise implementation.
-    """
+    value = Value()
 
     def __init__(self, event=None, manager=None, onSet=None):
         "x.__init__(...) initializes x; see x.__class__.__doc__ for signature"
 
+        super(Result, self).__init__()
+
         self.event = event
         self.manager = manager
 
         self.onSet = onSet
 
-        self.result = False
+        self.done = False
         self.errors = False
-        self._parent = self
-        self._value = None
 
     def __getstate__(self):
-        keys = ("event", "onSet", "result", "errors", "_value")
+        keys = ("event", "onSet", "done", "errors", "value")
         return dict([(k, getattr(self, k, None)) for k in keys])
 
-    def __contains__(self, y):
-        value = self.value
-        return y in value if isinstance(value, list) else y == value
-
-    def __getitem__(self, y):
-        v = self.value[y]
-        if isinstance(v, Value):
-            return v.value
-        else:
-            return v
-
-    def __iter__(self):
-        return map(lambda v: v.value if isinstance(v, Value) else v,
-                self.value)
-
     def __repr__(self):
         "x.__repr__() <==> repr(x)"
 
-        value = ""
-        if self.result:
-            value = repr(self.value)
-
-        format = "<Value (%s) result: %r errors: %r for %r"
-        return format % (value, self.result, self.errors, self.event)
-
-    def __str__(self):
-        "x.__str__() <==> str(x)"
-
-        return str(self.value)
-
-    def getValue(self):
-        value = self._value
-        while isinstance(value, Value):
-            value = value._value
-        return value
-
-    def setValue(self, value):
-        if isinstance(value, Value):
-            value._parent = self
-
-        if self.result and isinstance(self._value, list):
-            self._value.append(value)
-        elif self.result:
-            self._value = [self._value]
-            self._value.append(value)
-        else:
-            self._value = value
-
-        def notify(o, v):
-            if not isinstance(v, Value) and v is not None:
-                o.result = True
-                if o.manager is not None and o.onSet is not None:
-                    o.manager.fireEvent(ValueChanged(o), *o.onSet)
-            elif isinstance(v, Value):
-                o.errors = v.errors
-                o.result = v.result
-            if not o._parent == o:
-                o._parent.errors = o.errors
-                o._parent.result = o.result
-                notify(o._parent, v)
-        
-        notify(self, value)
-
-    value = property(getValue, setValue, None, "Value of this Value")
+        format = "<Result (done: %r errors: %r) for %r>"
+        return format % (self.done, self.errors, self.event)
diff --git a/tmp/test_lazy_evaluation.py b/tmp/test_lazy_evaluation.py
new file mode 100755
--- /dev/null
+++ b/tmp/test_lazy_evaluation.py
@@ -0,0 +1,29 @@
+#!/usr/bin/env python
+
+from circuits import Component, Event
+
+class Test(Event):
+    """Test Event"""
+
+class Foo(Event):
+    """Foo Event"""
+
+class Bar(Event):
+    """Bar Event"""
+
+class App(Component):
+
+    def foo(self):
+        return 1
+
+    def bar(self):
+        return 2
+
+    def test(self):
+        a = self.fire(Foo())
+        b = self.fire(Bar())
+        return a.value + b.value
+
+from circuits import Debugger
+app = App() + Debugger()
+app.start()
